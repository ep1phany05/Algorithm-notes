- **回溯算法 = 递归 + 路径记录 + 回退**
  - 像一棵决策树，每个节点代表一个选择
  - 深度优先遍历这棵树 (一条路走到黑)
  - 遇到死路就返回上一层 (回溯)

- **递归与回溯的关系**
  - 递归负责纵向深入 (往更深层探索)
  - 回溯负责横向回退 (返回上一层尝试其他选择)

- **常见问题类型和解决思路**
  - **组合问题**和**分割问题**都是收集树的叶子节点
  - **子集问题**是找树的所有节点
  - **排列问题**要求有序，for从0开始，其中**全排列问题**需要used数组标记使用过的元素
  - **组合问题**无序，for从start/index开始，避免重复

- **算法复杂度**
  - 时间复杂度: 通常是指数级 (O(2^n) 或 O(n!))
  - 空间复杂度: O(n) (主要取决于递归深度)

- **python 代码模板**

    ```python
    result = []  # 存储最终结果
    path = []    # 记录当前路径

    def backtracking(参数):
        if 终止条件:
            result.append(path.copy())  # 注意要拷贝！
            return
        
        for 选择 in 当前可选集合:
            做选择(更新path)
            backtracking(新参数)  # 递归
            撤销选择(path.pop())
    ```

- **为什么需要path.pop()**
  - 想象你走迷宫时用粉笔做标记
  - 回退时要擦掉当前标记 (恢复现场)

- **什么时候需要start/index**
  - 如果是一个集合来求组合的话，就需要start/index (例如：77.组合 (opens new window)，216.组合总和III)
  - 如果是多个集合取组合，各个集合之间相互不影响，那么就不用start/index (例如：17.电话号码的字母组合)

- **Python拷贝机制**

    | 操作方式         | 内存行为                | 适用场景                      | 时间复杂度 |
    |------------------|-------------------------|------------------------------|------------|
    | 直接赋值         | 共享内存                | 需要同步修改的场景            | O(1)       |
    | list.copy() 或 path[:]     | 浅拷贝 (仅复制外层容器) | 一维列表的复制               | O(n)       |
    | copy.deepcopy() | 深拷贝 (递归复制所有层)  | 嵌套容器 (列表套列表/字典)    | O(n)       |

    ```python
    import copy

    origin = [1, [2, 3], 4]
    shallow = origin.copy()      # 浅拷贝
    deep = copy.deepcopy(origin) # 深拷贝

    # 修改内层列表
    origin[1].append(5)

    print(shallow)  # [1, [2, 3, 5], 4] ← 内层被影响
    print(deep)     # [1, [2, 3], 4]    ← 完全独立
    ```

    ```markdown
    原始列表 origin
    │
    ├─ 0: 1 (不可变类型)
    ├─ 1: ↆ → 指向子列表 [2,3] 的内存
    └─ 2: 4 (不可变类型)

    浅拷贝 shallow
    │
    ├─ 0: 1 
    ├─ 1: ↆ → 指向同一个子列表内存
    └─ 2: 4

    深拷贝 deep
    │
    ├─ 0: 1 
    ├─ 1: ↪ → 指向新复制的子列表内存 [2,3]
    └─ 2: 4
    ```

- **常见误区排查清单**
  - 发现结果列表全空 → 忘记拷贝直接存储引用
  - 嵌套列表出现意外修改 → 应该用深拷贝却用了浅拷贝
  - 性能低下 → 对简单结构使用深拷贝造成浪费
  - 误以为元组不需要拷贝 → 元组虽不可变，但内部可变元素仍受影响
