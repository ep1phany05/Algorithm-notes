- **回溯算法 = 递归 + 路径记录 + 回退**
  - 像一棵决策树，每个节点代表一个选择
  - 深度优先遍历这棵树 (一条路走到黑)
  - 遇到死路就返回上一层 (回溯)

- **递归与回溯的关系**
  - 递归负责纵向深入 (往更深层探索)
  - 回溯负责横向回退 (返回上一层尝试其他选择)

- **常见问题类型和解决思路**
  - **组合问题**和**分割问题**都是收集树的叶子节点
  - **子集问题**是找树的所有节点
  - **排列问题**要求有序，for从0开始，其中**全排列问题**需要used数组标记使用过的元素
  - **组合问题**无序，for从start/index开始，避免重复

- **算法复杂度**
  - **子集问题**：
    - 时间复杂度: O(n × 2ⁿ)

      每个元素有“选”或“不选”两种状态，共生成 2ⁿ 个子集。每次生成子集需 O(n) 时间复制到结果列表。

    - 空间复杂度: O(n)

      主要取决于递归深度，递归深度为 n（系统栈空间），path 和 result 为全局引用，不额外占用空间。

  - **组合问题**：
    - 时间复杂度:O(n × 2ⁿ)（若为所有可能的组合）

      组合问题本质是子集问题的特例（如选 k 个元素），最坏情况（遍历所有 k）与子集复杂度相同。若固定选 k 个，则为 **O(k × C(n, k))**，其中 C(n, k) 是组合数。

    - 空间复杂度: O(n)

      递归深度为 n，与子集问题一致。

  - **排列问题**：
    - 时间复杂度: O(n × n!)

      共有 n! 种排列，每个排列生成时需 O(n) 时间复制到结果列表。虽然常简化为 O(n!)，但严格分析应包含 n 的系数。

    - 空间复杂度: O(n)

      递归深度为 n，每层递归仅用常数空间。

- **python 代码模板**

    ```python
    result = []  # 存储最终结果
    path = []    # 记录当前路径

    def backtracking(参数):
        if 终止条件:
            result.append(path.copy())  # 注意要拷贝！
            return
        
        for 选择 in 当前可选集合:
            做选择(更新path)
            backtracking(新参数)  # 递归
            撤销选择(path.pop())
    ```

- **为什么需要path.pop()**
  - 想象你走迷宫时用粉笔做标记
  - 回退时要擦掉当前标记 (恢复现场)

- **什么时候需要start/index**
  - 如果是一个集合来求组合的话，就需要start/index (例如：77.组合 (opens new window)，216.组合总和III)
  - 如果是多个集合取组合，各个集合之间相互不影响，那么就不用start/index (例如：17.电话号码的字母组合)

- **Python拷贝机制**

    | 操作方式         | 内存行为                | 适用场景                      | 时间复杂度 |
    |------------------|-------------------------|------------------------------|------------|
    | 直接赋值         | 共享内存                | 需要同步修改的场景            | O(1)       |
    | list.copy() 或 path[:]     | 浅拷贝 (仅复制外层容器) | 一维列表的复制               | O(n)       |
    | copy.deepcopy() | 深拷贝 (递归复制所有层)  | 嵌套容器 (列表套列表/字典)    | O(n)       |

    ```python
    import copy

    origin = [1, [2, 3], 4]
    shallow = origin.copy()      # 浅拷贝
    deep = copy.deepcopy(origin) # 深拷贝

    # 修改内层列表
    origin[1].append(5)

    print(shallow)  # [1, [2, 3, 5], 4] ← 内层被影响
    print(deep)     # [1, [2, 3], 4]    ← 完全独立
    ```

    ```markdown
    原始列表 origin
    │
    ├─ 0: 1 (不可变类型)
    ├─ 1: ↆ → 指向子列表 [2,3] 的内存
    └─ 2: 4 (不可变类型)

    浅拷贝 shallow
    │
    ├─ 0: 1 
    ├─ 1: ↆ → 指向同一个子列表内存
    └─ 2: 4

    深拷贝 deep
    │
    ├─ 0: 1 
    ├─ 1: ↪ → 指向新复制的子列表内存 [2,3]
    └─ 2: 4
    ```
  
- **dict与defaultdict**
  - **defaultdict**: collections 中的 defaultdict 是 Python 的一个字典子类，它在**访问不存在的键时，不会抛出 KeyError 异常**，而是会自动使用一个默认的工厂函数来创建该键的值。

    ```python
      dict = defaultdict(factory_function)  # 接受一个工厂函数作为参数
    ```

    factory_function 可以是 list、set、str 等等，作用是当 key 不存在时，返回的是工厂函数的默认值，比如**list 对应 [ ]，str 对应的是空字符串，set 对应 set( )，int 对应 0**。

  - **dict**: 使用 dict[key] 时，若 key 不存在则报错；使用 dict.get(key) 时，若key不存在则会返回一个默认值。

- **常见误区排查清单**
  - 发现结果列表全空 → 忘记拷贝直接存储引用
  - 嵌套列表出现意外修改 → 应该用深拷贝却用了浅拷贝
  - 性能低下 → 对简单结构使用深拷贝造成浪费
  - 误以为元组不需要拷贝 → 元组虽不可变，但内部可变元素仍受影响
